// This file was auto-generated by Fern from our API Definition.

package tesseral

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/tesseral-labs/tesseral-sdk-go/internal"
	time "time"
)

type GetProjectResponse struct {
	// The requested Project.
	Project *Project `json:"project,omitempty" url:"project,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetProjectResponse) GetProject() *Project {
	if g == nil {
		return nil
	}
	return g.Project
}

func (g *GetProjectResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetProjectResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetProjectResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetProjectResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetProjectResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

// Projects are the top-level object in Tesseral.
//
//	Everything in Tesseral happens within the context of a Project.
type Project struct {
	// The Project ID. Starts with `project_...`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// A human-friendly name for the Project.
	DisplayName *string `json:"displayName,omitempty" url:"displayName,omitempty"`
	// When the Project was created.
	CreateTime *time.Time `json:"createTime,omitempty" url:"createTime,omitempty"`
	// When the Project was last modified.
	UpdateTime *time.Time `json:"updateTime,omitempty" url:"updateTime,omitempty"`
	// Whether the Project supports "Log in with Google".
	LogInWithGoogle *bool `json:"logInWithGoogle,omitempty" url:"logInWithGoogle,omitempty"`
	// Whether the Project supports "Log in with Microsoft".
	LogInWithMicrosoft *bool `json:"logInWithMicrosoft,omitempty" url:"logInWithMicrosoft,omitempty"`
	// Whether the Project supports "Log in with email".
	LogInWithEmail *bool `json:"logInWithEmail,omitempty" url:"logInWithEmail,omitempty"`
	// Whether the Project supports "Log in with password".
	LogInWithPassword *bool `json:"logInWithPassword,omitempty" url:"logInWithPassword,omitempty"`
	// Whether the Project supports "Log in with SAML".
	LogInWithSAML *bool `json:"logInWithSaml,omitempty" url:"logInWithSaml,omitempty"`
	// Whether the Project supports authenticator apps as a secondary auth factor.
	LogInWithAuthenticatorApp *bool `json:"logInWithAuthenticatorApp,omitempty" url:"logInWithAuthenticatorApp,omitempty"`
	// Whether the Project supports passkeys as a secondary auth factor.
	LogInWithPasskey *bool `json:"logInWithPasskey,omitempty" url:"logInWithPasskey,omitempty"`
	// The OAuth Client ID to use for "Log in with Google".
	GoogleOauthClientID *string `json:"googleOauthClientId,omitempty" url:"googleOauthClientId,omitempty"`
	// The OAuth Client Secret to use for "Log in with Google".
	//
	//	This field is write-only.
	GoogleOauthClientSecret *string `json:"googleOauthClientSecret,omitempty" url:"googleOauthClientSecret,omitempty"`
	// The OAuth Client ID to use for "Log in with Microsoft".
	MicrosoftOauthClientID *string `json:"microsoftOauthClientId,omitempty" url:"microsoftOauthClientId,omitempty"`
	// The OAuth Client Secret to use for "Log in with Microsoft".
	//
	//	This field is write-only.
	MicrosoftOauthClientSecret *string `json:"microsoftOauthClientSecret,omitempty" url:"microsoftOauthClientSecret,omitempty"`
	// The domain where the Project's Vault lives.
	VaultDomain *string `json:"vaultDomain,omitempty" url:"vaultDomain,omitempty"`
	// Whether vault_domain is different from the automatically-assigned one.
	VaultDomainCustom *bool `json:"vaultDomainCustom,omitempty" url:"vaultDomainCustom,omitempty"`
	// The set of domains the Project trusts.
	//
	//	Client-side JavaScript on these domains can take actions on behalf of
	//	logged-in Users.
	TrustedDomains []string `json:"trustedDomains,omitempty" url:"trustedDomains,omitempty"`
	// The domain that authentication cookies are stored on.
	CookieDomain *string `json:"cookieDomain,omitempty" url:"cookieDomain,omitempty"`
	// Where Users are redirected after returning from the Vault.
	RedirectURI *string `json:"redirectUri,omitempty" url:"redirectUri,omitempty"`
	// Where Users are redirected after logging in.
	AfterLoginRedirectURI *string `json:"afterLoginRedirectUri,omitempty" url:"afterLoginRedirectUri,omitempty"`
	// Where Users are redirected after signing up.
	AfterSignupRedirectURI *string `json:"afterSignupRedirectUri,omitempty" url:"afterSignupRedirectUri,omitempty"`
	// Emails sent to Users come from this domain.
	EmailSendFromDomain *string `json:"emailSendFromDomain,omitempty" url:"emailSendFromDomain,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (p *Project) GetID() *string {
	if p == nil {
		return nil
	}
	return p.ID
}

func (p *Project) GetDisplayName() *string {
	if p == nil {
		return nil
	}
	return p.DisplayName
}

func (p *Project) GetCreateTime() *time.Time {
	if p == nil {
		return nil
	}
	return p.CreateTime
}

func (p *Project) GetUpdateTime() *time.Time {
	if p == nil {
		return nil
	}
	return p.UpdateTime
}

func (p *Project) GetLogInWithGoogle() *bool {
	if p == nil {
		return nil
	}
	return p.LogInWithGoogle
}

func (p *Project) GetLogInWithMicrosoft() *bool {
	if p == nil {
		return nil
	}
	return p.LogInWithMicrosoft
}

func (p *Project) GetLogInWithEmail() *bool {
	if p == nil {
		return nil
	}
	return p.LogInWithEmail
}

func (p *Project) GetLogInWithPassword() *bool {
	if p == nil {
		return nil
	}
	return p.LogInWithPassword
}

func (p *Project) GetLogInWithSAML() *bool {
	if p == nil {
		return nil
	}
	return p.LogInWithSAML
}

func (p *Project) GetLogInWithAuthenticatorApp() *bool {
	if p == nil {
		return nil
	}
	return p.LogInWithAuthenticatorApp
}

func (p *Project) GetLogInWithPasskey() *bool {
	if p == nil {
		return nil
	}
	return p.LogInWithPasskey
}

func (p *Project) GetGoogleOauthClientID() *string {
	if p == nil {
		return nil
	}
	return p.GoogleOauthClientID
}

func (p *Project) GetGoogleOauthClientSecret() *string {
	if p == nil {
		return nil
	}
	return p.GoogleOauthClientSecret
}

func (p *Project) GetMicrosoftOauthClientID() *string {
	if p == nil {
		return nil
	}
	return p.MicrosoftOauthClientID
}

func (p *Project) GetMicrosoftOauthClientSecret() *string {
	if p == nil {
		return nil
	}
	return p.MicrosoftOauthClientSecret
}

func (p *Project) GetVaultDomain() *string {
	if p == nil {
		return nil
	}
	return p.VaultDomain
}

func (p *Project) GetVaultDomainCustom() *bool {
	if p == nil {
		return nil
	}
	return p.VaultDomainCustom
}

func (p *Project) GetTrustedDomains() []string {
	if p == nil {
		return nil
	}
	return p.TrustedDomains
}

func (p *Project) GetCookieDomain() *string {
	if p == nil {
		return nil
	}
	return p.CookieDomain
}

func (p *Project) GetRedirectURI() *string {
	if p == nil {
		return nil
	}
	return p.RedirectURI
}

func (p *Project) GetAfterLoginRedirectURI() *string {
	if p == nil {
		return nil
	}
	return p.AfterLoginRedirectURI
}

func (p *Project) GetAfterSignupRedirectURI() *string {
	if p == nil {
		return nil
	}
	return p.AfterSignupRedirectURI
}

func (p *Project) GetEmailSendFromDomain() *string {
	if p == nil {
		return nil
	}
	return p.EmailSendFromDomain
}

func (p *Project) GetExtraProperties() map[string]interface{} {
	return p.extraProperties
}

func (p *Project) UnmarshalJSON(data []byte) error {
	type embed Project
	var unmarshaler = struct {
		embed
		CreateTime *internal.DateTime `json:"createTime,omitempty"`
		UpdateTime *internal.DateTime `json:"updateTime,omitempty"`
	}{
		embed: embed(*p),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*p = Project(unmarshaler.embed)
	p.CreateTime = unmarshaler.CreateTime.TimePtr()
	p.UpdateTime = unmarshaler.UpdateTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *p)
	if err != nil {
		return err
	}
	p.extraProperties = extraProperties
	p.rawJSON = json.RawMessage(data)
	return nil
}

func (p *Project) MarshalJSON() ([]byte, error) {
	type embed Project
	var marshaler = struct {
		embed
		CreateTime *internal.DateTime `json:"createTime,omitempty"`
		UpdateTime *internal.DateTime `json:"updateTime,omitempty"`
	}{
		embed:      embed(*p),
		CreateTime: internal.NewOptionalDateTime(p.CreateTime),
		UpdateTime: internal.NewOptionalDateTime(p.UpdateTime),
	}
	return json.Marshal(marshaler)
}

func (p *Project) String() string {
	if len(p.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(p.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(p); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", p)
}
