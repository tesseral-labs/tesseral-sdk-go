// This file was auto-generated by Fern from our API Definition.

package tesseral

import (
	json "encoding/json"
	fmt "fmt"
	internal "github.com/tesseral-labs/tesseral-sdk-go/internal"
	time "time"
)

type SessionsListSessionsRequest struct {
	// The User ID.
	UserID *string `json:"-" url:"userId,omitempty"`
	// A pagination token. Leave empty to get the first page of results.
	PageToken *string `json:"-" url:"pageToken,omitempty"`
}

type GetSessionResponse struct {
	// The requested Session.
	Session *Session `json:"session,omitempty" url:"session,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (g *GetSessionResponse) GetSession() *Session {
	if g == nil {
		return nil
	}
	return g.Session
}

func (g *GetSessionResponse) GetExtraProperties() map[string]interface{} {
	return g.extraProperties
}

func (g *GetSessionResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler GetSessionResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*g = GetSessionResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *g)
	if err != nil {
		return err
	}
	g.extraProperties = extraProperties
	g.rawJSON = json.RawMessage(data)
	return nil
}

func (g *GetSessionResponse) String() string {
	if len(g.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(g.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(g); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", g)
}

type ListSessionsResponse struct {
	// A list of Sessions.
	Sessions []*Session `json:"sessions,omitempty" url:"sessions,omitempty"`
	// The pagination token for the next page of results. Empty if there is no next page.
	NextPageToken *string `json:"nextPageToken,omitempty" url:"nextPageToken,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (l *ListSessionsResponse) GetSessions() []*Session {
	if l == nil {
		return nil
	}
	return l.Sessions
}

func (l *ListSessionsResponse) GetNextPageToken() *string {
	if l == nil {
		return nil
	}
	return l.NextPageToken
}

func (l *ListSessionsResponse) GetExtraProperties() map[string]interface{} {
	return l.extraProperties
}

func (l *ListSessionsResponse) UnmarshalJSON(data []byte) error {
	type unmarshaler ListSessionsResponse
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*l = ListSessionsResponse(value)
	extraProperties, err := internal.ExtractExtraProperties(data, *l)
	if err != nil {
		return err
	}
	l.extraProperties = extraProperties
	l.rawJSON = json.RawMessage(data)
	return nil
}

func (l *ListSessionsResponse) String() string {
	if len(l.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(l.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(l); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", l)
}

// Represents a Session for a logged-in User.
type Session struct {
	// The Session ID. Starts with `session_...`.
	ID *string `json:"id,omitempty" url:"id,omitempty"`
	// The User this Session belongs to.
	UserID *string `json:"userId,omitempty" url:"userId,omitempty"`
	// Whether the Session is revoked.
	Revoked *bool `json:"revoked,omitempty" url:"revoked,omitempty"`
	// When the Session was created.
	CreateTime *time.Time `json:"createTime,omitempty" url:"createTime,omitempty"`
	// When the Session was last active.
	LastActiveTime *time.Time `json:"lastActiveTime,omitempty" url:"lastActiveTime,omitempty"`
	// When the Session expires.
	ExpireTime *time.Time `json:"expireTime,omitempty" url:"expireTime,omitempty"`

	extraProperties map[string]interface{}
	rawJSON         json.RawMessage
}

func (s *Session) GetID() *string {
	if s == nil {
		return nil
	}
	return s.ID
}

func (s *Session) GetUserID() *string {
	if s == nil {
		return nil
	}
	return s.UserID
}

func (s *Session) GetRevoked() *bool {
	if s == nil {
		return nil
	}
	return s.Revoked
}

func (s *Session) GetCreateTime() *time.Time {
	if s == nil {
		return nil
	}
	return s.CreateTime
}

func (s *Session) GetLastActiveTime() *time.Time {
	if s == nil {
		return nil
	}
	return s.LastActiveTime
}

func (s *Session) GetExpireTime() *time.Time {
	if s == nil {
		return nil
	}
	return s.ExpireTime
}

func (s *Session) GetExtraProperties() map[string]interface{} {
	return s.extraProperties
}

func (s *Session) UnmarshalJSON(data []byte) error {
	type embed Session
	var unmarshaler = struct {
		embed
		CreateTime     *internal.DateTime `json:"createTime,omitempty"`
		LastActiveTime *internal.DateTime `json:"lastActiveTime,omitempty"`
		ExpireTime     *internal.DateTime `json:"expireTime,omitempty"`
	}{
		embed: embed(*s),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*s = Session(unmarshaler.embed)
	s.CreateTime = unmarshaler.CreateTime.TimePtr()
	s.LastActiveTime = unmarshaler.LastActiveTime.TimePtr()
	s.ExpireTime = unmarshaler.ExpireTime.TimePtr()
	extraProperties, err := internal.ExtractExtraProperties(data, *s)
	if err != nil {
		return err
	}
	s.extraProperties = extraProperties
	s.rawJSON = json.RawMessage(data)
	return nil
}

func (s *Session) MarshalJSON() ([]byte, error) {
	type embed Session
	var marshaler = struct {
		embed
		CreateTime     *internal.DateTime `json:"createTime,omitempty"`
		LastActiveTime *internal.DateTime `json:"lastActiveTime,omitempty"`
		ExpireTime     *internal.DateTime `json:"expireTime,omitempty"`
	}{
		embed:          embed(*s),
		CreateTime:     internal.NewOptionalDateTime(s.CreateTime),
		LastActiveTime: internal.NewOptionalDateTime(s.LastActiveTime),
		ExpireTime:     internal.NewOptionalDateTime(s.ExpireTime),
	}
	return json.Marshal(marshaler)
}

func (s *Session) String() string {
	if len(s.rawJSON) > 0 {
		if value, err := internal.StringifyJSON(s.rawJSON); err == nil {
			return value
		}
	}
	if value, err := internal.StringifyJSON(s); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", s)
}
